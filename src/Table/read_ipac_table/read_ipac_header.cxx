#include "../../Table.hxx"

#include "../read_ipac_table.hxx"

namespace {

std::vector<size_t> get_bar_offsets(std::string &str) {
    std::vector<size_t> offsets;
    for (size_t i = 0; i < str.size(); i++) {
        if (str[i] == '|') {
            offsets.push_back(i);
        }
    }
    if (offsets.size() < 2) {
        throw std::runtime_error("This IPAC Table is empty");
    }
    return offsets;
}

void check_bar_position(const std::vector<size_t> &bar_offsets, const std::string &line,
                        size_t line_num) {
    for (auto &offset : bar_offsets)
        if (line.size() <= offset || line.at(offset) != '|')
            throw std::runtime_error("In line " + std::to_string(line_num) +
                                     ", the bar '|' that should be at column " +
                                     std::to_string(offset + 1) + " is misaligned");
}
}  // namespace

size_t tablator::Table::read_ipac_header(
        std::istream &ipac_file, std::array<std::vector<std::string>, 4> &ipac_columns,
        std::vector<size_t> &ipac_column_offsets,
        std::vector<Labeled_Property> &labeled_resource_properties) {
    size_t line_num = 0;
    char first_character = ipac_file.peek();

    for (; ipac_file && first_character == '\\'; first_character = ipac_file.peek()) {
        std::string line;
        std::getline(ipac_file, line);
        ++line_num;
        if (line.size() == 1) continue;
        if (line[1] == ' ') {
            // Line starting with "\ " is a comment.
            add_comment(line.substr(2));
        } else {
            // Line starting with "\X" (X not a space) should be keyword definitions of
            // the form "\name = value".
            auto position_of_equal = line.find("=");
            if (position_of_equal == std::string::npos) {
                // Assume this is a comment missing the required space in position 1.
                add_comment(line.substr(1));
            } else {
                std::string key = boost::algorithm::trim_copy(
                        line.substr(1, position_of_equal - 1));

                // These two properties/keywords are generated by
                // write_ipac_table_header().
                if (boost::iequals(key, std::string(tablator::Table::FIXLEN_KEYWORD)) ||
                    boost::iequals(key, std::string(ROWS_RETRIEVED_KEYWORD))) {
                    continue;
                }
                std::string value =
                        boost::algorithm::trim_copy(line.substr(position_of_equal + 1));
                std::string value_substr = "";  // set default and adjust
                std::size_t first = value.find_first_not_of("\"'");
                if (first != std::string::npos) {
                    std::size_t last = value.find_last_not_of("\"'");
                    value_substr = value.substr(first, last - first + 1);
                }

                ATTRIBUTES attr_map;
                // Stick it in an INFO element, which itself must
                // have a NAME attribute.
                attr_map.insert(std::make_pair(ATTR_NAME, key));
                attr_map.insert(std::make_pair(ATTR_VALUE, value_substr));
                labeled_resource_properties.emplace_back(INFO, Property(attr_map));
            }
        }
    }

    size_t num_header_lines = 0;
    for (; ipac_file && first_character == '|';
         first_character = ipac_file.peek(), ++num_header_lines) {
        std::string line;
        std::getline(ipac_file, line);
        ++line_num;
        auto tab_position = line.find("\t");
        if (tab_position != std::string::npos)
            throw std::runtime_error("In line " + std::to_string(line_num + 1) +
                                     ", the header '" + line +
                                     "' contains tabs at character " +
                                     std::to_string(tab_position + 1));
        if (num_header_lines > 3) {
            throw std::runtime_error(
                    "The table has more than 4 header lines "
                    "starting with '|'.");
        }

        if (num_header_lines == 0) {
            ipac_column_offsets = get_bar_offsets(line);
        } else {
            check_bar_position(ipac_column_offsets, line, line_num);
        }
        // This split creates an empty element at the beginning and
        // end.  We keep the beginning to mark the null_bitfield_flag,
        // and pop off the end.
        boost::split(ipac_columns[num_header_lines], line, boost::is_any_of("|"));

        // FIXME: I think this error can never happen, because it would
        // have been caught by check_bar_position.
        if (ipac_columns[num_header_lines].size() < 2)
            throw std::runtime_error(
                    "In line " + std::to_string(line_num) +
                    ", the table is missing header information in this line: '" + line +
                    "'");
        ipac_columns[num_header_lines].pop_back();

        for (auto &column : ipac_columns[num_header_lines]) {
            boost::algorithm::trim(column);
        }

		// JTODO why check only '<'? Did we handle '>' in check_bar_position?

        if (num_header_lines == 0) {
		  // First time through
            ipac_columns[COL_NAME_IDX][0] = null_bitfield_flags_name;
        } else if (num_header_lines == 1) {
            if (ipac_columns[COL_NAME_IDX].size() != ipac_columns[COL_TYPE_IDX].size())
                throw std::runtime_error(
                        "Wrong number of data types in line " +
                        std::to_string(line_num) + ". Expected " +
                        std::to_string(ipac_columns[COL_NAME_IDX].size()) +
                        " but found " + std::to_string(ipac_columns[COL_TYPE_IDX].size()));
        } else if (num_header_lines == 2 && ipac_columns[COL_NAME_IDX].size() <
                                                    ipac_columns[COL_UNIT_IDX].size()) {
            throw std::runtime_error("Too many values for units in line  " +
                                     std::to_string(line_num) + ".  Expected at most " +
                                     std::to_string(ipac_columns[COL_NAME_IDX].size()) +
                                     " but found " +
                                     std::to_string(ipac_columns[COL_UNIT_IDX].size()));
        } else if (num_header_lines == 3 && ipac_columns[COL_NAME_IDX].size() <
                                                    ipac_columns[COL_NULL_IDX].size()) {
            throw std::runtime_error("Too many values for null in line  " +
                                     std::to_string(line_num) + ".  Expected at most " +
                                     std::to_string(ipac_columns[COL_NAME_IDX].size()) +
                                     " but found " +
                                     std::to_string(ipac_columns[COL_NULL_IDX].size()));
        }
    } // end of loop through lines beginning with '|'

    if (num_header_lines < 1) {
        throw std::runtime_error(
                "Could not find any lines starting with "
                "'|' for the names of the columns.");
    }
    if (num_header_lines < 2) {
        throw std::runtime_error(
                "Could not find any lines starting with "
                "'|' for the data types of the columns.");
    }

	// JTODO don't we have a problem if they don't already match up?  Or are we filling in blank lines?
    ipac_columns[COL_UNIT_IDX].resize(ipac_columns[COL_NAME_IDX].size());
    ipac_columns[COL_NULL_IDX].resize(ipac_columns[COL_NAME_IDX].size());

    return line_num;
}

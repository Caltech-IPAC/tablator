#include "../../Table.hxx"


namespace {

std::vector<size_t> get_bar_offsets(std::string &str) {
    std::vector<size_t> offsets;
    for (size_t i = 0; i < str.size(); i++) {
        if (str[i] == '|') {
            offsets.push_back(i);
        }
    }
    if (offsets.size() < 2) {
        throw std::runtime_error("This IPAC Table is empty");
    }
    return offsets;
}

void check_bar_position(const std::vector<size_t> &bar_offsets, const std::string &line,
                        size_t line_num) {
    for (auto &offset : bar_offsets)
        if (line.size() <= offset || line.at(offset) != '|')
            throw std::runtime_error("In line " + std::to_string(line_num) +
                                     ", the bar '|' that should be at column " +
                                     std::to_string(offset + 1) + " is misaligned");
}
}  // namespace

size_t tablator::Table::read_ipac_header(
        std::istream &ipac_file, std::array<std::vector<std::string>, 4> &columns,
        std::vector<size_t> &ipac_column_offsets,
        std::vector<Labeled_Property> &labeled_resource_properties) {
    size_t line_num = 0;
    char first_character = ipac_file.peek();

    for (; ipac_file && first_character == '\\'; first_character = ipac_file.peek()) {
        std::string line;
        std::getline(ipac_file, line);
        ++line_num;
        if (line.size() == 1) continue;
        if (line[1] == ' ') {
            // Line starting with "\ " is a comment.
            add_comment(line.substr(2));
        } else {
            // Line starting with "\X" (X not a space) should be keyword definitions of
            // the form "\name = value".
            auto position_of_equal = line.find("=");
            if (position_of_equal == std::string::npos) {
                // Assume this is a comment missing the required space in position 1.
                add_comment(line.substr(1));
            } else {
                std::string key = boost::algorithm::trim_copy(
                        line.substr(1, position_of_equal - 1));

                // These two properties/keywords are generated by
                // write_ipac_table_header().
                if (boost::iequals(key, std::string(tablator::Table::FIXLEN_KEYWORD)) ||
                    boost::iequals(key, std::string(ROWS_RETRIEVED_KEYWORD))) {
                    continue;
                }
                std::string value =
                        boost::algorithm::trim_copy(line.substr(position_of_equal + 1));
                std::string value_substr = "";  // set default and adjust
                std::size_t first = value.find_first_not_of("\"'");
                if (first != std::string::npos) {
                    std::size_t last = value.find_last_not_of("\"'");
                    value_substr = value.substr(first, last - first + 1);
                }

                // JTODO INFO, name, value
                ATTRIBUTES attr_map;
                if (boost::iequals(key, std::string(tablator::TYPE)) ||
                    boost::iequals(key, std::string(tablator::UTYPE)) ||
                    boost::iequals(key, std::string(tablator::NAME)) ||
                    boost::iequals(key, std::string(tablator::ID))) {
                    // The valid RESOURCE attributes
                    attr_map.insert(std::make_pair(key, value_substr));
                    labeled_resource_properties.emplace_back("", Property(attr_map));
                } else {
                    // Not a RESOURCE attribute, so stick it in an INFO element,
                    // which itself must have NAME attribute.
                    attr_map.insert(std::make_pair(ATTR_NAME, key));
                    attr_map.insert(std::make_pair(ATTR_VALUE, value_substr));
                    labeled_resource_properties.emplace_back(INFO, Property(attr_map));
                }
            }
        }
    }
    size_t header_line_num = 0;
    for (; ipac_file && first_character == '|';
         first_character = ipac_file.peek(), ++header_line_num) {
        std::string line;
        std::getline(ipac_file, line);
        ++line_num;
        auto tab_position = line.find("\t");
        if (tab_position != std::string::npos)
            throw std::runtime_error("In line " + std::to_string(line_num + 1) +
                                     ", the header '" + line +
                                     "' contains tabs at character " +
                                     std::to_string(tab_position + 1));
        if (header_line_num > 3) {
            throw std::runtime_error(
                    "The table has more than 4 header lines "
                    "starting with '|'.");
        }

        if (header_line_num == 0) {
            ipac_column_offsets = get_bar_offsets(line);
        } else {
            check_bar_position(ipac_column_offsets, line, line_num);
        }
        /// This split creates an empty element at the beginning and
        /// end.  We keep the beginning to mark the null_bitfield_flag,
        /// and pop off the end
        boost::split(columns[header_line_num], line, boost::is_any_of("|"));

        /// FIXME: I think this error can never happen, because it would
        /// have been caught by check_bar_position.
        if (columns[header_line_num].size() < 2)
            throw std::runtime_error(
                    "In line " + std::to_string(line_num) +
                    ", the table is missing header information in this line: '" + line +
                    "'");
        columns[header_line_num].pop_back();
        for (auto &column : columns[header_line_num]) boost::algorithm::trim(column);

        if (header_line_num == 0) {
            columns[0][0] = null_bitfield_flags_name;
        } else if (header_line_num == 1) {
            if (columns[0].size() != columns[1].size())
                throw std::runtime_error("Wrong number of data types in line " +
                                         std::to_string(line_num) + ". Expected " +
                                         std::to_string(columns[0].size()) +
                                         " but found " +
                                         std::to_string(columns[1].size()));
        } else if (header_line_num == 2 && columns[0].size() < columns[2].size()) {
            throw std::runtime_error("Too many values for units in line  " +
                                     std::to_string(line_num) + ".  Expected at most " +
                                     std::to_string(columns[0].size()) + " but found " +
                                     std::to_string(columns[2].size()));
        } else if (header_line_num == 3 && columns[0].size() < columns[3].size()) {
            throw std::runtime_error("Too many values for null in line  " +
                                     std::to_string(line_num) + ".  Expected at most " +
                                     std::to_string(columns[0].size()) + " but found " +
                                     std::to_string(columns[3].size()));
        }
    }

    if (header_line_num < 1) {
        throw std::runtime_error(
                "Could not find any lines starting with "
                "'|' for the names of the columns.");
    }
    if (header_line_num < 2) {
        throw std::runtime_error(
                "Could not find any lines starting with "
                "'|' for the data types of the columns.");
    }
    columns[2].resize(columns[0].size());
    columns[3].resize(columns[0].size());
    return line_num;
}

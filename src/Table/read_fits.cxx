#include <regex>
#include <unordered_map>

#include <CCfits/CCfits>

#include "../Common.hxx"
#include "../Data_Details.hxx"
#include "../Field_Framework.hxx"
#include "../Table.hxx"
#include "../fits_keyword_ucd_mapping.hxx"
#include "../string_to_Data_Type.hxx"

// Note: ccfits_table->rows () returns an int, so there may be issues
// with FITS files containing more than 2^32 rows.

// JTODO Descriptions get lost in conversion to and from FITS format.

//(We can't yet convert to FITS format VOTables with more than one RESOURCE.
// 07Dec20)

// As of 28Jun25, all columns are created with dynamic_array_flag value <false>.

namespace {


//====================================================
// Helper functions for reading keywords
//====================================================


//====================================================


// If the present FITS file was created by write_fits() from a table
// in VOTable format, the table's labeled_properties,
// trailing_info_lists, and attributes were translated into FITs
// keywords. The read_keywords_as_tablator_elements() function
// attempts to recover those VOTable-style elements.

// Since FITS has better support for long keyword values than for long
// keys, write_fits() stores names of the aforementioned VOTable-style
// elements ("prop_labels") as part of keyword values rather than
// as FITS keys.  The FITS keys for these values are strings of the
// form VOTABLE_KEYWORD_HEAD followed by consecutive integers N; their
// only purpose is to support sorting by N so that values
// corresponding to a single VOTable element can be processed as a
// group.  The string LABEL_END_MARKER indicates where the prop_label
// ends and the string corresponding to the element's <value_> (or
// value of one of its attributes_) begins.  For example:

// FITS key: {VOTABLE_KEYWORD_HEAD}3
// FITS value: VOTABLE.RESOURCE.INFO.ADQL.<xmlattr>ucd{LABEL_END_MARKER}meta.adql

// In general,  prop_labels generated by write_fits() have the following form:

// <votable_element_name>.<prop_name>.{XMLATTR}.<attr_name>
//   (for elements of prop.attributes_), or
//
// <votable_element_name>.<prop_name>.{XMLATTR}.{ATTR_IRSA_VALUE}
//   (for prop.value_)

// where <votable_element_name> is on the lines of
// "VOTABLE.RESOURCE.INFO" and <prop_name> is the value of the
// property's ATTR_NAME attribute, assumed to be non-empty and
// distinct for INFO elements.

//(We can't yet convert VOTables with more than one RESOURCE to FITS format.
// 07Dec20)


//====================================================
//====================================================

class Keyword_Reader {
public:
    //====================================================

    // Extract and store FITS keywords, which may include FITS-ified
    // labeled_properties/trailing_info_lists/attributes that resulted
    // from calling write_fits() on a VOTable.  Keys associated to such
    // translated elements are simply sequential placeholders; all data
    // from those elements are stored in the value part of the (key,
    // value) keyword pair.

    std::tuple<tablator::Labeled_Properties, std::vector<tablator::Field>,
               std::map<std::string, tablator::ATTRIBUTES>>
    read_keywords_as_tablator_elements(CCfits::HDU &table_extension,
                                       const std::string &extname_keyword,
                                       const std::string &extension_name) {
        static constexpr char const *DEFAULT_EXTNAME = "Table";

        if (!extension_name.empty() &&
            !boost::iequals(extension_name, DEFAULT_EXTNAME)) {
            tablator::Property extname_prop;
            extname_prop.add_attribute(tablator::ATTR_VALUE, extension_name);
            combined_labeled_properties_.emplace_back(
                    tablator::Labeled_Property(extname_keyword, extname_prop));
        }

        // Retrieve FITS (key, value) pairs and sort by key. Pairs corresponding to
        // the same VOTable element (as described above) will be consecutive.

        table_extension.readAllKeys();
        std::map<std::string, CCfits::Keyword *> &orig_kwd_map =
                table_extension.keyWord();
        std::vector<std::pair<std::string, CCfits::Keyword *>> sorted_kwd_map(
                orig_kwd_map.begin(), orig_kwd_map.end());

        static uint votable_prefix_size = tablator::VOTABLE_KEYWORD_HEAD.size();
        std::sort(
                sorted_kwd_map.begin(), sorted_kwd_map.end(),
                [](const std::pair<std::string, CCfits::Keyword *> &lhs,
                   const std::pair<std::string, CCfits::Keyword *> &rhs) {
                    const auto &lhs_first = lhs.first;
                    const auto &rhs_first = rhs.first;
                    if (boost::starts_with(lhs_first, tablator::VOTABLE_KEYWORD_HEAD) &&
                        boost::starts_with(rhs_first, tablator::VOTABLE_KEYWORD_HEAD)) {
                        return (std::stoi(lhs_first.substr(votable_prefix_size)) <
                                std::stoi(rhs_first.substr(votable_prefix_size)));
                    }
                    return (lhs_first < rhs_first);
                });

        Keyword_Reader_Packet keyword_reader_packet;

        for (auto &kwd : sorted_kwd_map) {
            std::string kwd_key(kwd.first);
            auto kwd_word = kwd.second;

            // Annoyingly, CCfits does not have a way to just return the
            // value.  You have to give it something to put it in.
            std::string kwd_value;
            get_keyword_value_as_string(kwd_value, kwd_word);

            if (!decode_fits_keyword(keyword_reader_packet, kwd_key, kwd_word,
                                     kwd_value)) {
                continue;
            }
            construct_tablator_element_if_moving_on(keyword_reader_packet,
                                                    false /* is_final_element */);

            unpack_decoded_keyword(keyword_reader_packet, kwd_word, kwd_value);
        }
        construct_tablator_element_if_moving_on(keyword_reader_packet,
                                                true /* is_final_element */);

        return std::make_tuple(combined_labeled_properties_, table_element_params_,
                               table_element_field_attributes_);
    }

    //====================================================

private:
    // This function retrieves keyword values of certain keytypes in
    // string form.  It propagates the exception CCfits throws when
    // asked to retrieve, in string form, the value of a keytype for
    // which this operation is unsupported, e.g. Tcomplex.
    static void get_keyword_value_as_string(std::string &value_str,
                                            const CCfits::Keyword *keyword) {
        if (keyword->keytype() == CCfits::Tlogical) {
            // std::cout << "type logical" << std::endl;
            bool value_bool;
            keyword->value(value_bool);
            value_str.assign(value_bool ? "true" : "false");
        } else if (keyword->keytype() == CCfits::Tint) {
            // std::cout << "type int" << std::endl;
            int value_int;
            keyword->value(value_int);
            value_str.assign(std::to_string(value_int));
        } else if (keyword->keytype() == CCfits::Tlong) {
            // std::cout << "type long" << std::endl;
            long value_long;
            keyword->value(value_long);
            value_str.assign(std::to_string(value_long));
        } else if (keyword->keytype() == CCfits::Tulong ||
                   keyword->keytype() == CCfits::Tlonglong) {
            // std::cout << "type longlong" << std::endl;
            long long value_longlong;
            keyword->value(value_longlong);
            value_str.assign(std::to_string(value_longlong));
        } else if (keyword->keytype() == CCfits::Tfloat) {
            // std::cout << "type float" << std::endl;
            float value_float;
            keyword->value(value_float);
            value_str.assign(std::to_string(value_float));
        } else if (keyword->keytype() == CCfits::Tdouble) {
            // std::cout << "type double" << std::endl;
            double value_double;
            keyword->value(value_double);
            value_str.assign(std::to_string(value_double));
        } else {
            keyword->value(value_str);
        }
    }

    //====================================================

    enum class Keyword_Type { PARAM, FIELD, LABELED_PROPERTY };

    struct Keyword_Reader_Packet {
        Keyword_Reader_Packet()
                : kwd_type_(Keyword_Type::LABELED_PROPERTY),
                  prev_kwd_type_(Keyword_Type::LABELED_PROPERTY),
                  param_datatype_(static_cast<int>(tablator::Data_Type::CHAR)),
                  param_array_size_(1),
                  convert_value_to_attr_(false),
                  found_ucd_attr_for_prop_(false) {}


        // We'll store data temporarily in these two containers during the loop.
        tablator::Property prop_;
        tablator::ATTRIBUTES attributes_;

        // Loop variables passed between parent class's functions.
        std::string prop_identifier_;
        std::string prev_prop_identifier_;

        std::string prop_label_;
        std::string prev_prop_label_;

        Keyword_Type kwd_type_;
        Keyword_Type prev_kwd_type_;

        std::string helper_name_;
        std::string prev_helper_name_;

        std::string attr_name_;

        int param_datatype_;
        size_t param_array_size_;

        bool convert_value_to_attr_;
        bool found_ucd_attr_for_prop_;

    };  // end of Keyword_Reader_Packet

    //====================================================


    // "Decoding" is for keywords in files converted by tablator to
    // FITS format from e.g. VOTable format.

    // This function returns true unless the keyword is to be ignored.
    static bool decode_fits_keyword(Keyword_Reader_Packet &krp, std::string &kwd_key,
                                    CCfits::Keyword *kwd_word_ptr,
                                    std::string &kwd_value) {
        static std::vector<std::string> fits_ignored_keywords{{"LONGSTRN"}};

        krp.prev_kwd_type_ = krp.kwd_type_;
        krp.prev_helper_name_ = krp.helper_name_;

        // If <kwd> was generated from a LABELED_PROPERTIES
        // element by write_fits(), then the kwd_value string
        // includes the value of ATTR_NAME for that property;
        // similarly for PARAM and FIELD elements.  We group
        // together all kwd_values whose prefixes agree through
        // the ATTR_NAME value and construct from them an element
        // of the appropriate type whose label we extract from
        // their common prefix.

        static std::regex label_expr{"^(.+)" + tablator::LABEL_END_MARKER + "(.+)$",
                                     std::regex::icase};
        static std::regex attr_expr{"^(.+)\\." + tablator::XMLATTR + "\\." + "(.+)$",
                                    std::regex::icase};
        static std::regex info_expr{"^((?:.+\\.)?" + tablator::INFO + ")" + "\\." +
                                    "(.+)$"};

        static std::regex param_expr{"^((?:.+\\.)?" + tablator::PARAM + ")" + "\\." +
                                     "(.+)$"};

        static std::regex field_expr{"^((?:.+\\.)?" + tablator::FIELD + ")" + "\\." +
                                     "(.+)$"};

        std::smatch label_match;

        // Set defaults and adjust below.
        krp.prop_identifier_.assign(kwd_key);
        krp.prop_label_.assign(krp.prop_identifier_);
        krp.attr_name_.assign(krp.prop_identifier_);
        krp.kwd_type_ = Keyword_Type::LABELED_PROPERTY;
        krp.convert_value_to_attr_ = false;
        krp.helper_name_ = "";  //  Non-empty only for PARAM and FIELD.

        if (kwd_word_ptr->keytype() == CCfits::Tstring) {
            if (std::regex_match(kwd_value, label_match, label_expr)) {
                krp.prop_identifier_.assign(label_match[1]);
                krp.attr_name_.assign(boost::to_lower_copy(krp.prop_identifier_));

                krp.prop_label_.assign(krp.prop_identifier_);
                kwd_value.assign((label_match[2]));

                std::smatch attr_match;
                if (std::regex_match(krp.prop_identifier_, attr_match, attr_expr)) {
                    // Undo write_fits() hackery: extract prop_label
                    // and attrname from current prop_identifier,
                    // which looks like "prop_label.XMLATTR.name".

                    krp.prop_identifier_.assign(attr_match[1]);
                    krp.prop_label_.assign(krp.prop_identifier_);

                    krp.attr_name_.assign(attr_match[2]);

                    if (!boost::equals(krp.attr_name_, tablator::ID)) {
                        // FITS stores keywords in upper-case but IVOA
                        // wants attribute names other than ID to be
                        // lower-cased.
                        boost::to_lower(krp.attr_name_);
                    }

                    // If prop_identifier indicates that we are
                    // looking at an INFO element, we further undo
                    // write_fits() hackery by dropping everything
                    // past INFO from prop_label.  (prop_label strings
                    // need not be distinct.)  We don't modify
                    // prop_identifier, which contains prop_name and
                    // will be used to test whether it is time to wrap
                    // up the current labeled_properties element.

                    std::smatch info_param_match;
                    if (std::regex_match(krp.prop_identifier_, info_param_match,
                                         info_expr)) {
                        krp.prop_label_.assign(info_param_match[1]);

                    } else if (std::regex_match(krp.prop_identifier_, info_param_match,
                                                param_expr)) {
                        krp.kwd_type_ = Keyword_Type::PARAM;
                        krp.prop_label_.assign(info_param_match[1]);
                        krp.helper_name_.assign(info_param_match[2]);

                    } else if (std::regex_match(krp.prop_identifier_, info_param_match,
                                                field_expr)) {
                        krp.kwd_type_ = Keyword_Type::FIELD;
                        krp.prop_label_.assign(info_param_match[1]);
                        krp.helper_name_.assign(info_param_match[2]);

                    } else {
                        if (boost::equals(krp.prop_label_,
                                          tablator::VOTABLE_RESOURCE) ||
                            boost::equals(krp.prop_label_,
                                          tablator::VOTABLE_RESOURCE_TABLE)) {
                            // Otherwise, prepare for an attribute at the level of e.g.
                            // RESOURCE or TABLE.
                            krp.prop_label_ += tablator::DOT + tablator::XMLATTR;
                        }
                    }
                } else {
                    // std::cout << "info_expr matched but not attr_expr." << std::endl;
                }
            } else {
                // Plain old keyword straight from FITS (not a VOTable attribute via
                // write_fits()).
                if (std::find(fits_ignored_keywords.begin(),
                              fits_ignored_keywords.end(),
                              krp.attr_name_) != fits_ignored_keywords.end()) {
                    return false;
                }
                // We'll create an INFO element with attr pairs (ATTR_NAME, attr_name)
                // and (ATTR_IRSA_VALUE, kwd_value).
                krp.convert_value_to_attr_ = true;
            }
        } else {
            // not Tstring
            // JTODO Use datatype attr to preserve datatype of non-string keywords.
            krp.convert_value_to_attr_ = true;
        }
        return true;
    }

    //====================================================

    static void unpack_decoded_keyword(Keyword_Reader_Packet &krp,
                                       CCfits::Keyword *kwd_word_ptr,
                                       std::string &kwd_value) {
        static const auto keyword_ucd_mapping =
                tablator::fits_keyword_ucd_mapping(false);

        // Unpack into current prop_ or attributes_, depending on kwd_type.

        if (krp.kwd_type_ == Keyword_Type::PARAM) {
            if (krp.attr_name_ == "datatype") {
                krp.param_datatype_ =
                        static_cast<int>(tablator::string_to_Data_Type(kwd_value));
            } else if (krp.attr_name_ == "arraysize") {
                try {
                    krp.param_array_size_ = std::stol(kwd_value);
                } catch (std::exception &e) {
                    // Could be "*"
                }
            } else {
                krp.attributes_.emplace(std::make_pair(krp.attr_name_, kwd_value));
            }
        }

        else if (krp.kwd_type_ == Keyword_Type::FIELD) {
            krp.attributes_.emplace(std::make_pair(krp.attr_name_, kwd_value));
        }

        else {  // (krp.kwd_type_ == Keyword_Type::LABELED_PROPERTY)
            if (krp.convert_value_to_attr_) {
                // if kwd came from genuine FITS keyword
                krp.prop_.add_attribute(tablator::ATTR_VALUE, kwd_value);
            } else if (krp.attr_name_ == tablator::ATTR_IRSA_VALUE) {
                // if kwd came from FITS-ified labeled_properties.value_ via
                // write_fits()
                krp.prop_.set_value(kwd_value);

            } else {
                // kwd came from FITS-ified element of labeled_properties.attributes_
                // via write_fits()
                krp.prop_.add_attribute(krp.attr_name_, kwd_value);
            }

            if (!kwd_word_ptr->comment().empty()) {
                krp.prop_.add_attribute("comment", kwd_word_ptr->comment());
            }
        }
    }

    //====================================================

    void construct_tablator_element_if_moving_on(Keyword_Reader_Packet &krp,
                                                 bool is_final_element) {
        bool is_a_wrap = false;

        if (krp.prev_kwd_type_ == Keyword_Type::LABELED_PROPERTY) {
            if (is_final_element ||
                (krp.prop_identifier_ != krp.prev_prop_identifier_)) {
                // Save the prop-in-progress with the appropriate label and
                // prepare to move on.

                if (!krp.prev_prop_label_.empty() && !krp.prop_.empty()) {
                    combined_labeled_properties_.emplace_back(krp.prev_prop_label_,
                                                              krp.prop_);
                    krp.prop_.clear();
                }
                krp.prev_prop_identifier_.assign(krp.prop_identifier_);
                krp.prev_prop_label_.assign(krp.prop_label_);
                is_a_wrap = true;
            }

        } else if (krp.prev_kwd_type_ == Keyword_Type::PARAM) {
            if (is_final_element || (krp.kwd_type_ != Keyword_Type::PARAM ||
                                     krp.helper_name_ != krp.prev_helper_name_)) {
                table_element_params_.emplace_back(
                        krp.prev_helper_name_,
                        static_cast<tablator::Data_Type>(krp.param_datatype_),
                        krp.param_array_size_,
                        tablator::Field_Properties(krp.attributes_));
                krp.attributes_.clear();

                krp.param_datatype_ = static_cast<int>(tablator::Data_Type::CHAR);
                krp.param_array_size_ = 1;
                is_a_wrap = true;
            }

        } else if (krp.prev_kwd_type_ == Keyword_Type::FIELD) {
            if (!krp.attributes_.empty() &&
                (is_final_element || krp.kwd_type_ != Keyword_Type::FIELD ||
                 krp.helper_name_ != krp.prev_helper_name_)) {
                table_element_field_attributes_.emplace(krp.prev_helper_name_,
                                                        krp.attributes_);
                krp.attributes_.clear();
                is_a_wrap = true;
            }
        }

        if (is_a_wrap || !krp.found_ucd_attr_for_prop_) {
            krp.found_ucd_attr_for_prop_ = (krp.attr_name_ == tablator::ATTR_UCD);
        }

        if (!is_final_element && is_a_wrap && !krp.found_ucd_attr_for_prop_) {
            // If we wrapped the previous tablator element and are
            // starting another and don't yet have a UCD attribute,
            // check whether <attr_name> is a key of
            // keyword_ucd_mapping.  If so, concoct a UCD attribute
            // using keyword_ucd_mapping.  If a UCD attribute for this
            // element shows up later on, we'll overwrite the one
            // we're adding now.

            // JTODO This keyword_ucd_mapping business is a relic and
            // perhaps not a good idea (04Apr21).

            static const auto keyword_ucd_mapping =
                    tablator::fits_keyword_ucd_mapping(false);
            auto i = keyword_ucd_mapping.find(krp.attr_name_);
            if (i != keyword_ucd_mapping.end()) {
                krp.prop_.add_attribute(tablator::ATTR_UCD, i->second);
            }
        }
    }  // end of construct_tablator_element_if_moving_on()

    // We'll load these three containers during the loop through sorted_kwd_map.
    tablator::Labeled_Properties combined_labeled_properties_;
    std::vector<tablator::Field> table_element_params_;
    std::map<std::string, tablator::ATTRIBUTES> table_element_field_attributes_;


};  // end of Keyword_Reader class

//====================================================
// Helper functions/classes for parsing binary data
//====================================================

// There is more than one way to indicate the array_size of a FITS column.
// JTODO We don't yet support dynamic array columns in FITS format.  28Jun25
size_t get_array_size(const CCfits::Column &fits_col) {
    size_t array_size = 1;
    if (std::isdigit(fits_col.format().at(0))) {
        array_size = std::stoll(fits_col.format());
    } else {
        // Capture e.g. "PK(5)".
        static std::regex format_regex{R"(([0-9]+))"};
        std::smatch number_match;
        bool format_contains_paren_number =
                std::regex_search(fits_col.format(), number_match, format_regex);
        if (format_contains_paren_number) {
            array_size = std::stoi(number_match[1]);
        }
    }
    return array_size;
}

//=====================================================
//====================================================

// Helper class that stores column-level metadata for later use by
// functions that read and store binary data.

class Column_Info_Manager {
public:
    // This un-templatized version is called for data_types for which
    // CCfits::getNullValue() is not defined.
    void store_data_type_info_for_column(tablator::Data_Type tab_data_type,
                                         size_t array_size) {
        column_info_list_.emplace_back(tab_data_type, array_size, false /* got_null */,
                                       0 /* null_list_idx */);
    }

    //=====================================================

    template <typename T>
    void store_info_for_column(bool &got_null, T &null_value,
                               const CCfits::Column &fits_col,
                               tablator::Data_Type tab_data_type, size_t array_size) {
        got_null = false;
        null_value = 0;
        if (is_null_value_supported(tab_data_type)) {
            // CCCfits::getNullValue() is surprisingly slow, in my
            // limited experience.  Storing its value as we do here
            // allows us to call this function only once for each column
            // rather than once for every combination of column and row.
            got_null = fits_col.getNullValue(&null_value);
        }

        size_t null_list_idx = 0;
        if (got_null) {
            null_list_idx = store_null_value_for_type(tab_data_type, null_value);
        }
        column_info_list_.emplace_back(tab_data_type, array_size, got_null,
                                       null_list_idx);
    }

    //=====================================================

    template <typename T>
    void retrieve_info_for_column(tablator::Data_Type &tab_data_type,
                                  size_t &array_size, bool &got_null, T &null_value,
                                  size_t tab_col_idx) const {
        // The vector column_info_list_ is indexed from 0, but the
        // non-null_bitfield_flags columns of the tablator table are
        // indexed from 1.
        const Column_Info &col_info = column_info_list_.at(tab_col_idx - 1);
        tab_data_type = col_info.tab_data_type_;
        array_size = col_info.array_size_;
        got_null = col_info.got_null_;
        if (got_null) {
            null_value = retrieve_null_value_for_type<T>(tab_data_type,
                                                         col_info.null_list_idx_);
        }
    }

    //=====================================================

    size_t retrieve_array_size_for_column(size_t tab_col_idx) const {
        const Column_Info &col_info = column_info_list_.at(tab_col_idx - 1);
        return col_info.array_size_;
    }

private:
    //=====================================================

    bool is_null_value_supported(tablator::Data_Type data_type) const {
        return (data_type >= tablator::Data_Type::UINT8_LE &&
                data_type <= tablator::Data_Type::UINT64_LE);
    }

    //=====================================================

    template <typename T>
    size_t store_null_value_for_type(tablator::Data_Type tab_data_type, T null_value) {
        size_t idx = 0;
        switch (tab_data_type) {
            case tablator::Data_Type::UINT8_LE: {
                idx = uint8_null_values_.size();
                uint8_null_values_.emplace_back(null_value);
            } break;
            case tablator::Data_Type::INT16_LE: {
                idx = int16_null_values_.size();
                int16_null_values_.emplace_back(null_value);
            } break;
            case tablator::Data_Type::UINT16_LE: {
                idx = uint16_null_values_.size();
                uint16_null_values_.emplace_back(null_value);
            } break;
            case tablator::Data_Type::INT32_LE: {
                idx = int32_null_values_.size();
                int32_null_values_.emplace_back(null_value);
            } break;
            case tablator::Data_Type::UINT32_LE: {
                idx = uint32_null_values_.size();
                uint32_null_values_.emplace_back(null_value);
            } break;
            case tablator::Data_Type::INT64_LE: {
                idx = int64_null_values_.size();
                int64_null_values_.emplace_back(null_value);
            } break;
            default:
                throw std::runtime_error("Unknown tablator data type");
        }
        return idx;
    }

    template <typename T>
    T retrieve_null_value_for_type(tablator::Data_Type tab_data_type,
                                   size_t null_list_idx) const {
        switch (tab_data_type) {
            case tablator::Data_Type::UINT8_LE: {
                return uint8_null_values_.at(null_list_idx);
            } break;
            case tablator::Data_Type::INT16_LE: {
                return int16_null_values_.at(null_list_idx);
            } break;
            case tablator::Data_Type::UINT16_LE: {
                return uint16_null_values_.at(null_list_idx);
            } break;
            case tablator::Data_Type::INT32_LE: {
                return int32_null_values_.at(null_list_idx);
            } break;
            case tablator::Data_Type::UINT32_LE: {
                return uint32_null_values_.at(null_list_idx);
            } break;
            case tablator::Data_Type::INT64_LE: {
                return int64_null_values_.at(null_list_idx);
            } break;
            default:
                throw std::runtime_error(
                        "tablator data type not supported for this function.XXX");
        }
        return 0;
    }

    //=====================================================

    struct Column_Info {
        Column_Info(tablator::Data_Type tdt, size_t as, bool gn, size_t nli)
                : tab_data_type_(tdt),
                  array_size_(as),
                  got_null_(gn),
                  null_list_idx_(nli) {}

        tablator::Data_Type tab_data_type_;
        size_t array_size_;
        bool got_null_;
        size_t null_list_idx_;
    };

    // Storage for type-specific per-column null_values
    std::vector<uint8_t> uint8_null_values_;
    std::vector<int16_t> int16_null_values_;
    std::vector<uint16_t> uint16_null_values_;
    std::vector<int32_t> int32_null_values_;
    std::vector<uint32_t> uint32_null_values_;
    std::vector<int64_t> int64_null_values_;


    std::vector<Column_Info> column_info_list_;
};


//====================================================
//====================================================


class Row_Column_Element_Reader {
public:
    Row_Column_Element_Reader(const Column_Info_Manager &col_info_manager,
                              const std::vector<size_t> &offsets)
            : col_info_manager_(col_info_manager), offsets_(offsets){};


    template <typename T>
    void read_element_given_column_and_row(tablator::Row &row, fitsfile *fits_file,
                                           const CCfits::Column &fits_col,
                                           size_t fits_row_idx, size_t tab_col_idx) {
        // Use the C api because the C++ api (Column::readArrays) is
        // horrendously slow.
        tablator::Data_Type tab_data_type;
        size_t array_size;
        bool got_null = false;
        T null_value = 0;
        col_info_manager_.retrieve_info_for_column(tab_data_type, array_size, got_null,
                                                   null_value, tab_col_idx);

        size_t col_offset = offsets_[tab_col_idx];
        size_t next_col_offset = offsets_[tab_col_idx + 1];

        auto get_matched_datatype = CCfits::FITSUtil::MatchType<T>();
        char *curr_ptr = row.get_data().data() + col_offset;

        std::vector<T> temp_array(array_size);
        int status = 0;
        int anynul = 0;

        fits_read_col(fits_file, get_matched_datatype(), fits_col.index(), fits_row_idx,
                      1, array_size, NULL /* nulval */, temp_array.data(), &anynul,
                      &status);

        if (anynul) {
            // Indicate that all array_size values are null.

            // Note: As of 13Oct23, the only value I have seen for anynul is 0.
            row.insert_null(tab_data_type, array_size, tab_col_idx, col_offset,
                            next_col_offset);
        } else {
            for (size_t array_offset = 0; array_offset < array_size; ++array_offset) {
                T array_elt = temp_array[array_offset];
                if (got_null && array_elt == null_value) {
                    // Indicate that a single value in the array is null.
                    row.insert_null(tab_data_type, 1 /* array_size */, tab_col_idx,
                                    col_offset + (array_offset * sizeof(T)),
                                    next_col_offset);
                } else if ((tab_data_type == tablator::Data_Type::FLOAT32_LE ||
                            tab_data_type == tablator::Data_Type::FLOAT64_LE) &&
                           std::isnan(array_elt)) {
                    // Do these types separately, both because FITS doesn't (or didn't)
                    // allow columns of these types to specify a NULL signal and because
                    // equality check doesn't work with NaN, which appears to be the
                    // default NULL signal for these types, at least for Euclid files.
                    row.insert_null(tab_data_type, 1 /* array_size */, tab_col_idx,
                                    col_offset + (array_offset * sizeof(T)),
                                    next_col_offset);
                } else {
                    *reinterpret_cast<T *>(curr_ptr) = array_elt;
                    curr_ptr += sizeof(T);
                }
            }
        }
    }

    //====================================================

    // Note: FITS thinks of elements of Tstring columns as strings---or
    // possibly arrays of strings---but tablator thinks of each such
    // element as a single character array, not an array of arrays.
    // This function does not check whether individual elements of that
    // single array are undefined/null.
    void read_string_given_column_and_row(tablator::Row &row, fitsfile *fits_file,
                                          const CCfits::Column &fits_col,
                                          size_t fits_row_idx, size_t tab_col_idx) {
        // array_size is the size of the column in bytes/chars.
        size_t array_size =
                col_info_manager_.retrieve_array_size_for_column(tab_col_idx);

        size_t col_offset = offsets_[tab_col_idx];
        size_t next_col_offset = offsets_[tab_col_idx + 1];

        // If this string column is a vector column, all of the array
        // elements (henceforth "substrings") have the same size: the
        // value of CCfits::Column::width().
        size_t substring_size = fits_col.width();
        size_t num_substrings = array_size / substring_size;

        if (array_size != num_substrings * substring_size) {
            throw std::runtime_error(
                    "array_size is not an exact multiple of substring_size.");
        }

        // fits_read_col_str() wants a char** argument.  Create such an
        // element using vectors so as not to have to deal with memory
        // allocation and deallocation.
        std::vector<char *> ptr_vec;

        std::vector<std::vector<char>> data_vec(num_substrings,
                                                std::vector<char>(substring_size + 1));
        for (size_t i = 0; i < num_substrings; ++i) {
            ptr_vec.emplace_back(data_vec.at(i).data());
        }
        // Finally, the char**.
        char **data_str = ptr_vec.data();

        tablator::Data_Type tab_col_type = tablator::Data_Type::CHAR;
        char nulstr[] = "";
        int status = 0;
        int anynul = 0;

        fits_read_col_str(fits_file, fits_col.index(), fits_row_idx, 1 /* firstelem */,
                          num_substrings /* nelements */, nulstr, data_str, &anynul,
                          &status);

        if (anynul) {
            row.insert_null(tab_col_type, fits_col.repeat(), tab_col_idx, col_offset,
                            next_col_offset);
        } else {
            char *current = row.get_data().data() + col_offset;
            for (size_t i = 0; i < num_substrings; ++i) {
                char *element = data_str[i];
                size_t elt_length = strlen(element);
                size_t j = 0;
                for (/* */; j < elt_length && j < substring_size; ++j) {
                    *(current + j) = *(element + j);
                }
                for (/* */; j < substring_size; ++j) {
                    *(current + j) = '\0';
                }
            }
        }
    }

private:
    const Column_Info_Manager &col_info_manager_;
    const std::vector<size_t> &offsets_;
};


}  // namespace

//====================================================
//====================================================

void tablator::Table::read_fits(const boost::filesystem::path &path) {
    CCfits::FITS fits(path.string(), CCfits::Read, false);

    static constexpr char const *PRIMARY_EXTNAME = "PRIMARY_EXTNAME";
    static constexpr char const *TABLE_EXTNAME = "TABLE_EXTNAME";

    if (fits.extension().empty())
        throw std::runtime_error("Could not find any extensions in this file: " +
                                 path.string());

    tablator::Labeled_Properties combined_labeled_properties;
    std::vector<Field> table_element_params;
    std::map<std::string, ATTRIBUTES> table_element_field_attributes;

    //*********************************************************
    // Retrieve FITS keywords in the form of labeled_properties.
    //*********************************************************

    Keyword_Reader keyword_reader;

    // Retrieve FITS keywords from primary HDU

    keyword_reader.read_keywords_as_tablator_elements(fits.pHDU(), PRIMARY_EXTNAME,
                                                      fits.currentExtensionName());

    // Retrieve FITS keywords from the first extension.  JTODO add extension_idx option?

    CCfits::ExtHDU &table_extension = fits.extension(1);
    CCfits::BinTable *ccfits_table(dynamic_cast<CCfits::BinTable *>(&table_extension));

    std::tie(combined_labeled_properties, table_element_params,
             table_element_field_attributes) =
            keyword_reader.read_keywords_as_tablator_elements(
                    table_extension, TABLE_EXTNAME, fits.currentExtensionName());

    //*********************************************************
    // Distribute the labeled_properties between assorted class
    // members at assorted levels.
    //*********************************************************

    Labeled_Properties resource_element_labeled_properties;
    std::vector<Property> resource_element_trailing_infos;
    ATTRIBUTES resource_element_attributes;
    std::vector<Property> table_element_trailing_infos;
    ATTRIBUTES table_element_attributes;
    distribute_metadata(resource_element_labeled_properties,
                        resource_element_trailing_infos, resource_element_attributes,
                        table_element_trailing_infos, table_element_attributes,
                        combined_labeled_properties);


    //*********************************
    // Read and store binary data
    //*********************************

    std::vector<Column> orig_columns;

    // Create null_bitfield_flags column for internal use.
    orig_columns.emplace_back(null_bitfield_flags_name, Data_Type::UINT8_LE,
                              bits_to_bytes(ccfits_table->column().size()),
                              Field_Properties(null_bitfield_flags_description, {}));

    Column_Info_Manager col_info_manager;

    // We make two passes through the FITS file's columns.  The first
    // pass is to extract column metadata and create tablator columns;
    // the second pass is to read and store data.

    //*********************************************************
    // Retrieve column metadata.
    //*********************************************************

    for (size_t fits_col_idx = 1; fits_col_idx <= ccfits_table->column().size();
         ++fits_col_idx) {
        CCfits::Column &fits_col = ccfits_table->column(fits_col_idx);

        size_t array_size = get_array_size(fits_col);
        bool got_null = false;

        // Negative type indicates array-valued column.
        int abs_fits_type = abs(fits_col.type());

        switch (abs_fits_type) {
            case CCfits::Tlogical: {
                // std::cout << "Tlogical: " << CCfits::Tlogical << std::endl;
                orig_columns.emplace_back(fits_col.name(), Data_Type::INT8_LE,
                                          array_size);
                col_info_manager.store_data_type_info_for_column(Data_Type::UINT8_LE,
                                                                 array_size);
            } break;
            case CCfits::Tbyte: {
                // std::cout << "Tbyte: " << CCfits::Tbyte << std::endl;
                uint8_t null_value = 0;
                col_info_manager.store_info_for_column<uint8_t>(
                        got_null, null_value, fits_col, Data_Type::INT32_LE,
                        array_size);
                Field_Properties null_prop;
                null_prop.get_values().null =
                        got_null ? std::to_string(null_value) : DEFAULT_NULL_VALUE;
                orig_columns.emplace_back(fits_col.name(), Data_Type::UINT8_LE,
                                          array_size, null_prop);
            } break;
            case CCfits::Tshort: {
                // std::cout << "Tshort: " << CCfits::Tshort << std::endl;
                int16_t null_value = 0;
                col_info_manager.store_info_for_column<int16_t>(
                        got_null, null_value, fits_col, Data_Type::INT16_LE,
                        array_size);
                Field_Properties null_prop;
                null_prop.get_values().null =
                        got_null ? std::to_string(null_value) : DEFAULT_NULL_VALUE;
                orig_columns.emplace_back(fits_col.name(), Data_Type::INT16_LE,
                                          array_size, null_prop);
            } break;
            case CCfits::Tushort: {
                // std::cout << "Tushort: " << CCfits::Tushort << std::endl;
                uint16_t null_value = 0;
                col_info_manager.store_info_for_column<uint16_t>(
                        got_null, null_value, fits_col, Data_Type::UINT16_LE,
                        array_size);
                Field_Properties null_prop;
                null_prop.get_values().null =
                        got_null ? std::to_string(null_value) : DEFAULT_NULL_VALUE;
                orig_columns.emplace_back(fits_col.name(), Data_Type::UINT16_LE,
                                          array_size, null_prop);
            } break;
            case CCfits::Tint: {
                int32_t null_value = 0;
                col_info_manager.store_info_for_column<int32_t>(
                        got_null, null_value, fits_col, Data_Type::INT32_LE,
                        array_size);
                Field_Properties null_prop;
                null_prop.get_values().null =
                        got_null ? std::to_string(null_value) : DEFAULT_NULL_VALUE;
                orig_columns.emplace_back(fits_col.name(), Data_Type::INT32_LE,
                                          array_size, null_prop);
            } break;
            case CCfits::Tuint: {
                uint32_t null_value = 0;
                col_info_manager.store_info_for_column<uint32_t>(
                        got_null, null_value, fits_col, Data_Type::UINT32_LE,
                        array_size);
                Field_Properties null_prop;
                null_prop.get_values().null =
                        got_null ? std::to_string(null_value) : DEFAULT_NULL_VALUE;
                orig_columns.emplace_back(fits_col.name(), Data_Type::UINT32_LE,
                                          array_size, null_prop);
            } break;
            case CCfits::Tlong: {
                // The Tlong type code is used for 32-bit integer columns when reading.
                int32_t null_value = 0;
                col_info_manager.store_info_for_column<int32_t>(
                        got_null, null_value, fits_col, Data_Type::INT32_LE,
                        array_size);
                Field_Properties null_prop;
                null_prop.get_values().null =
                        got_null ? std::to_string(null_value) : DEFAULT_NULL_VALUE;
                orig_columns.emplace_back(fits_col.name(), Data_Type::INT32_LE,
                                          array_size, null_prop);
            } break;
            case CCfits::Tulong: {
                // The Tulong type code is used for 32-bit unsigned integer columns when
                // reading.
                uint32_t null_value = 0;
                col_info_manager.store_info_for_column<uint32_t>(
                        got_null, null_value, fits_col, Data_Type::UINT32_LE,
                        array_size);
                Field_Properties null_prop;
                null_prop.get_values().null =
                        got_null ? std::to_string(null_value) : DEFAULT_NULL_VALUE;
                orig_columns.emplace_back(fits_col.name(), Data_Type::UINT32_LE,
                                          array_size, null_prop);
            } break;
            case CCfits::Tlonglong: {
                int64_t null_value = 0;
                col_info_manager.store_info_for_column<int64_t>(
                        got_null, null_value, fits_col, Data_Type::INT64_LE,
                        array_size);
                Field_Properties null_prop;
                null_prop.get_values().null =
                        got_null ? std::to_string(null_value) : DEFAULT_NULL_VALUE;
                orig_columns.emplace_back(fits_col.name(), Data_Type::INT64_LE,
                                          array_size, null_prop);
            } break;
            case CCfits::Tfloat: {
                // std::cout << "Tfloat" << std::endl;
                Field_Properties null_prop;
                null_prop.get_values().null = DEFAULT_NULL_VALUE;
                orig_columns.emplace_back(fits_col.name(), Data_Type::FLOAT32_LE,
                                          array_size, null_prop);
                col_info_manager.store_data_type_info_for_column(Data_Type::FLOAT32_LE,
                                                                 array_size);
            } break;
            case CCfits::Tdouble: {
                // std::cout << "Tdouble" << std::endl;
                Field_Properties null_prop;
                null_prop.get_values().null = DEFAULT_NULL_VALUE;
                orig_columns.emplace_back(fits_col.name(), Data_Type::FLOAT64_LE,
                                          array_size, null_prop);
                col_info_manager.store_data_type_info_for_column(Data_Type::FLOAT64_LE,
                                                                 array_size);
            } break;
            case CCfits::Tstring:
                orig_columns.emplace_back(fits_col.name(), Data_Type::CHAR,
                                          fits_col.width());
                col_info_manager.store_data_type_info_for_column(Data_Type::CHAR,
                                                                 array_size);
                break;
            default:
                throw std::runtime_error(
                        "Appending columns, unsupported data type in the fits file for "
                        "column '" +
                        fits_col.name() + "'");
        }

        // Check whether keywords contained encoded attributes for this column.
        auto attr_iter = table_element_field_attributes.find(fits_col.name());
        if (attr_iter != table_element_field_attributes.end()) {
            orig_columns.back().get_field_properties().add_attributes(
                    attr_iter->second);
        }
    }

    Field_Framework field_framework(orig_columns, true /* got_null_bitfields_column */);
    auto &columns = field_framework.get_columns();
    auto &offsets = field_framework.get_offsets();

    Row_Column_Element_Reader element_reader(col_info_manager, offsets);

    size_t row_size = field_framework.get_row_size();
    size_t num_rows = ccfits_table->rows();

    tablator::Data_Details data_details(field_framework, num_rows);

    // CCfits dies in read_element_given_column_and_row() if there is no data in the
    // table. :(

    if (row_size > 0 && num_rows > 0) {
        fitsfile *fits_pointer = fits.fitsPointer();

        // Tablator columns are 0-based and FITS columns are 1-based,
        // but the tablator table has a null_bitfield_flags column in
        // the 0th place, which will be populated as a side effect of
        // populating the other columns of the tablator table.  All
        // columns but the 0th of the tablator table have the same
        // index as their counterpart in the FITS file.

        for (size_t j = 0; j < num_rows; ++j) {
            size_t fits_row_idx = j + 1;

            // Row by row, we'll populate <curr_row> and append it to <data>.
            Row curr_row(row_size);

            curr_row.fill_with_zeros();

            for (size_t i = 0; i < ccfits_table->column().size(); ++i) {
                size_t fits_col_idx = i + 1;
                size_t tab_col_idx = fits_col_idx;

                CCfits::Column &fits_col = ccfits_table->column(fits_col_idx);
                switch (abs(fits_col.type())) {
                    case CCfits::Tlogical: {
                        // Use template type uint8_t here; FITS doesn't support int8_t.
                        // null_value is not defined for this type.
                        // std::cout << "uint8" << std::endl;
                        element_reader.read_element_given_column_and_row<uint8_t>(
                                curr_row, fits_pointer, fits_col, fits_row_idx,
                                tab_col_idx);
                    } break;
                    case CCfits::Tbyte: {
                        // std::cout << "byte" << std::endl;
                        element_reader.read_element_given_column_and_row<uint8_t>(
                                curr_row, fits_pointer, fits_col, fits_row_idx,
                                tab_col_idx);
                    } break;
                    case CCfits::Tshort: {
                        // std::cout << "Tshort" << std::endl;
                        element_reader.read_element_given_column_and_row<int16_t>(
                                curr_row, fits_pointer, fits_col, fits_row_idx,
                                tab_col_idx);
                    } break;
                    case CCfits::Tushort: {
                        // std::cout << "Tushort" << std::endl;
                        element_reader.read_element_given_column_and_row<uint16_t>(
                                curr_row, fits_pointer, fits_col, fits_row_idx,
                                tab_col_idx);
                    } break;
                    case CCfits::Tint:
                    case CCfits::Tlong: {
                        // std::cout << "Tint or Tlong" << std::endl;
                        element_reader.read_element_given_column_and_row<int32_t>(
                                curr_row, fits_pointer, fits_col, fits_row_idx,
                                tab_col_idx);
                    } break;
                    case CCfits::Tuint:
                    case CCfits::Tulong: {
                        // std::cout << "Tuint or Tulong" << std::endl;
                        element_reader.read_element_given_column_and_row<uint32_t>(
                                curr_row, fits_pointer, fits_col, fits_row_idx,
                                tab_col_idx);
                    } break;
                    case CCfits::Tlonglong: {
                        // std::cout << "Tlonglong" << std::endl;
                        element_reader.read_element_given_column_and_row<int64_t>(
                                curr_row, fits_pointer, fits_col, fits_row_idx,
                                tab_col_idx);
                    } break;
                    case CCfits::Tfloat: {
                        // std::cout << "Tfloat" << std::endl;
                        element_reader.read_element_given_column_and_row<float>(
                                curr_row, fits_pointer, fits_col, fits_row_idx,
                                tab_col_idx);
                    } break;
                    case CCfits::Tdouble: {
                        // std::cout << "Tdouble" << std::endl;
                        element_reader.read_element_given_column_and_row<double>(
                                curr_row, fits_pointer, fits_col, fits_row_idx,
                                tab_col_idx);
                    } break;
                    case CCfits::Tstring: {
                        // std::cout << "Tstring" << std::endl;
                        // read_element_given_column_and_row() calls fits_read_col(),
                        // which is not supported for CCfits::Tstring.
                        element_reader.read_string_given_column_and_row(
                                curr_row, fits_pointer, fits_col, fits_row_idx,
                                tab_col_idx);
                    } break;
                    default:
                        throw std::runtime_error(
                                "Loading columns, unsupported data type in the fits "
                                "file for column " +
                                fits_col.name());
                }
                // FIXME: This should get the comment, but the comment()
                // function is protected???
                if (!fits_col.unit().empty()) {
                    columns[tab_col_idx].get_field_properties().add_attribute(
                            "unit", fits_col.unit());
                }
            }
            data_details.append_row(curr_row);
        }
    }

    //*********************************************************
    // Assemble resource element.
    //*********************************************************

    const auto table_element =
            Table_Element::Builder(field_framework, data_details)
                    .add_trailing_info_list(table_element_trailing_infos)
                    .add_attributes(table_element_attributes)
                    .add_params(table_element_params)
                    .build();
    add_resource_element(
            Resource_Element::Builder(table_element)
                    .add_labeled_properties(resource_element_labeled_properties)
                    .add_trailing_info_list(resource_element_trailing_infos)
                    .add_attributes(resource_element_attributes)
                    .build());
}

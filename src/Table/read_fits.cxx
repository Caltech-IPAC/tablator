#include <CCfits/CCfits>

#include <boost/algorithm/string/regex.hpp>

#include "../Table.hxx"
#include "../fits_keyword_ucd_mapping.hxx"

// JTODO Descriptions and field-level attributes get lost in conversion to and from
// fits.

namespace {

// CCfits does not make it easy to retrieve keyword values.  Only
// keyword values of keytypes Tint, Tfloat, Tdouble, and Tstring can
// be retrieved directly from CCfits in string form.

// This function retrieves values of the keytypes mentioned above as
// strings. It retrieves values of keytypes implicitly convertible to
// int as int and then converts them to string.  It propagates the
// exception CCfits throws when asked to retrieve a value of any other
// keytype, e.g. Tcomplex.

void get_keyword_value_as_string(std::string &value_str,
                                 const CCfits::Keyword *keyword) {
    if ((keyword->keytype() == CCfits::Tint || keyword->keytype() == CCfits::Tfloat ||
         keyword->keytype() == CCfits::Tdouble ||
         keyword->keytype() == CCfits::Tstring)) {
        keyword->value(value_str);
    } else if (keyword->keytype() == CCfits::Tlogical) {
        bool value_bool;
        keyword->value(value_bool);
        value_str.assign(value_bool ? "true" : "false");
    } else {
        // If the keytype is not convertible to int, value() will throw an exception.
        int value_int;
        keyword->value(value_int);
        value_str.assign(std::to_string(value_int));
    }
}

//************************************************************

template <typename T>
void read_scalar_column(uint8_t *position, CCfits::Column &c, const size_t &rows,
                        const size_t &row_size) {
    std::vector<T> v;
    c.read(v, 1, rows);
    uint8_t *current = position;
    for (auto &element : v) {
        *reinterpret_cast<T *>(current) = element;
        current += row_size;
    }
}

template <typename T>
void read_vector_column(fitsfile *fits_file, uint8_t *position, CCfits::Column &c,
                        const size_t &rows, const size_t &row_size) {
    // Use the C api because the C++ api (Column::readArrays) is
    // horrendously slow.
    int status(0), anynul(0);
    std::vector<T> temp_array(c.repeat());

    auto get_matched_datatype = CCfits::FITSUtil::MatchType<T>();
    uint8_t *current = position;
    for (size_t row = 0; row < rows; ++row) {
        uint8_t *element_start = current;

        fits_read_col(fits_file, get_matched_datatype(), c.index(), row + 1, 1,
                      c.repeat(), NULL, temp_array.data(), &anynul, &status);

        for (size_t offset = 0; offset < c.repeat(); ++offset) {
            *reinterpret_cast<T *>(current) = temp_array[offset];
            current += sizeof(T);
        }
        current = element_start + row_size;
    }
}

//************************************************************

template <typename T>
void read_column(fitsfile *fits_file, uint8_t *position, CCfits::Column &c,
                 const bool &is_array, const size_t &rows, const size_t &row_size) {
    if (!is_array)
        read_scalar_column<T>(position, c, rows, row_size);
    else
        read_vector_column<T>(fits_file, position, c, rows, row_size);
}

//************************************************************

// If the present FITS file was created by write_fits() from a table
// in VOTable format, the table's labeled_properties,
// trailing_info_lists, and attributes were translated into FITs
// keywords. The read_keywords_as_labeled_properties() function
// attempts to recover those VOTable-style elements.

// Since FITS has better support for long keyword values than for long
// keys, write_fits() stores names of the aforementioned VOTable-style
// elements ("prop_labels") as part of keyword values rather than
// as FITS keys.  The FITS keys for these values are strings of the
// form VOTABLE_KEYWORD_HEAD followed by consecutive integers N; their
// only purpose is to support sorting by N so that values
// corresponding to a single VOTable element can be processed as a
// group.  The string LABEL_END_MARKER indicates where the prop_label
// ends and the string corresponding to the element's <value_> (or
// value of one of its attributes_) begins.  For example:

// FITS key: {VOTABLE_KEYWORD_HEAD}3
// FITS value: VOTABLE.RESOURCE.INFO.ADQL.<xmlattr>ucd{LABEL_END_MARKER}meta.adql

// In general,  prop_labels generated by write_fits() have the following form:

// <votable_element_name>.<prop_name>.{XMLATTR}.<attr_name>
//   (for elements of prop.attributes_), or
//
// <votable_element_name>.<prop_name>.{XMLATTR}.{ATTR_IRSA_VALUE}
//   (for prop.value_)

// where <votable_element_name> is on the lines of
// "VOTABLE.RESOURCE.INFO" and <prop_name> is the value of the
// property's ATTR_NAME attribute, assumed to be non-empty and
// distinct for INFO elements.

//(We can't yet convert VOTables with more than one RESOURCE to FITS format.
// 07Dec20)

std::vector<std::pair<std::string, tablator::Property>>
read_keywords_as_labeled_properties(CCfits::ExtHDU &table_extension) {

    // Retrieve FITS <key, value> pairs and sort so that pairs corresponding to
    // labeled properties (as described above) are grouped together.
    table_extension.readAllKeys();
    std::map<std::string, CCfits::Keyword *> &orig_kwd_map = table_extension.keyWord();
    std::vector<std::pair<std::string, CCfits::Keyword *>> sorted_kwd_map(
            orig_kwd_map.begin(), orig_kwd_map.end());

    static uint votable_prefix_size = tablator::VOTABLE_KEYWORD_HEAD.size();
    std::sort(sorted_kwd_map.begin(), sorted_kwd_map.end(),
              [](const std::pair<std::string, CCfits::Keyword *> &lhs,
                 const std::pair<std::string, CCfits::Keyword *> &rhs) {
                  const auto &lhs_first = lhs.first;
                  const auto &rhs_first = rhs.first;
                  if (boost::starts_with(lhs_first, tablator::VOTABLE_KEYWORD_HEAD) &&
                      boost::starts_with(rhs_first, tablator::VOTABLE_KEYWORD_HEAD)) {
                      return (std::stoi(lhs_first.substr(votable_prefix_size)) <
                              std::stoi(rhs_first.substr(votable_prefix_size)));
                  }
                  return (lhs_first < rhs_first);
              });

    // Prepare for loop through kwd_map.
    static std::vector<std::string> fits_ignored_keywords{{"LONGSTRN"}};
    static const auto keyword_ucd_mapping = tablator::fits_keyword_ucd_mapping(false);

    // Extract labeled_properties/trailing_info_lists/attributes.
    // If this table was created by write_fits(), those elements
    // would have been converted to labeled_properties and stored as keywords
    // of the form

    // ELEMENT.<prop_name>.XMLATTR.<attr_name> : attr_value or
    // ELEMENT.<prop_name>.XMLATTR.ATTR_IRSA_VALUE : prop.value

    // where <prop_name> is the value of prop's ATTR_NAME attribute and is
    // assumed to be non-empty for INFO elements, of which we might have many.
    //(We can't yet convert to FITS format VOTables with more than one RESOURCE.
    // 07Dec20)

    tablator::Labeled_Properties combined_labeled_properties;
    std::string prev_prop_identifier = "";
    std::string prev_prop_label = "";
    tablator::Property prop;

    for (auto &kwd : sorted_kwd_map) {
        std::string kwd_key(kwd.first);
        auto kwd_word = kwd.second;

        // Annoyingly, CCfits does not have a way to just return the
        // value.  You have to give it something to put it in.
        std::string kwd_value;
        get_keyword_value_as_string(kwd_value, kwd_word);

        // Set to defaults and adjust as needed.
        std::string prop_identifier(kwd_key);
        std::string prop_label(prop_identifier);
        std::string name(prop_identifier);

        bool convert_value_to_attr = false;
        bool found_ucd_attr = false;

        if (kwd_word->keytype() == CCfits::Tstring) {
            // If <kwd> was generated from a labeled_properties
            // element by write_fits(), then the kwd_value string
            // includes the value of ATTR_NAME for that property.  We
            // group together all kwd_values whose prefixes agree
            // through the ATTR_NAME value and construct from them a
            // labeled_properties element whose label we extract from
            // their common prefix.

            static boost::regex label_expr{
                    "^(.*)" + tablator::LABEL_END_MARKER + "(.*)$",
                    boost::regex::icase};
            static boost::regex attr_expr{
                    "^(.*)\\." + tablator::XMLATTR + "\\." + "(.*)$",
                    boost::regex::icase};
            static boost::regex info_expr{"^((?:.*\\.)?" + tablator::INFO + ")" +
                                          "\\." + "(.*)$"};
            boost::smatch what;

            if (boost::regex_search(kwd_value, what, label_expr)) {
                prop_identifier.assign(what[1]);
                name.assign(prop_identifier);
                prop_label.assign(prop_identifier);
                kwd_value.assign((what[2]));

                if (boost::regex_search(prop_identifier, what, attr_expr)) {
                    // Undo write_fits() hackery: extract prop_label
                    // and attrname from current prop_identifier,
                    // which looks like "prop_label.XMLATTR.name".

                    prop_identifier.assign(what[1]);
                    prop_label.assign(prop_identifier);

                    name.assign((what[2]));

                    // If prop_identifier indicates that we are
                    // looking at an INFO element, we further undo
                    // write_fits() hackery by dropping everything
                    // past INFO from prop_label.  (prop_label strings
                    // need not be distinct.)  We don't modify
                    // prop_identifier, which contains prop_name and
                    // will be used to test whether it is time to wrap
                    // up the current labeled_properties element.

                    if (boost::regex_search(prop_identifier, what, info_expr)) {
                        prop_label.assign(what[1]);
                    } else {
                        // Otherwise, prepare for an attribute at the level of e.g.
                        // RESOURCE or TABLE.
                        prop_label += tablator::DOT + tablator::XMLATTR;
                    }
                } else {
                    std::cout << "hmm, info_attr matched but not attr_expr"
                              << std::endl;
                }
            } else {
                // Plain old keyword straight from FITS (not a VOTable attribute via
                // write_fits()).
                if (std::find(fits_ignored_keywords.begin(),
                              fits_ignored_keywords.end(),
                              name) != fits_ignored_keywords.end()) {
                    continue;
                }
                // We'll create an INFO element with attr pairs (ATTR_NAME, name) and
                // (ATTR_IRSA_VALUE, kwd_value).
                convert_value_to_attr = true;
            }
        }

        if (prop_identifier != prev_prop_identifier) {
            // Save the prop-in-progress with the appropriate label and
            // prepare to move on.
            if (!prev_prop_label.empty() && !prop.empty()) {
                combined_labeled_properties.emplace_back(
                        std::make_pair(prev_prop_label, prop));
                prop.clear();
            }

            prev_prop_identifier.assign(prop_identifier);
            prev_prop_label.assign(prop_label);
        }

        // Add attributes to current <prop>.
        if (!found_ucd_attr) {
            found_ucd_attr = (name == tablator::ATTR_UCD);
        }

        if (convert_value_to_attr) {
            // if kwd came from genuine FITS keyword
            prop.add_attribute(tablator::ATTR_VALUE, kwd_value);
        } else if (name == tablator::ATTR_IRSA_VALUE) {
            // if kwd came from FITS-ified labeled_properties.value_ via write_fits()
            prop.set_value(kwd_value);
        } else {
            // if kwd came from FITS-ified element of labeled_properties.attributes_ via
            // write_fits()
            prop.add_attribute(name, kwd_value);
        }

        if (!kwd.second->comment().empty()) {
            prop.add_attribute("comment", kwd.second->comment());
        }

        // If no UCD attribute associated to <name> has shown up so
        // far and <name> is a key of keyword_ucd_mapping, concoct a
        // UCD attribute using keyword_ucd_mapping.  If a UCD
        // attribute shows up later on, we'll overwrite the one we're
        // adding now.

        // JTODO This keyword_ucd_mapping business is a relic and
        // perhaps not a good idea (04Apr21).

        if (!found_ucd_attr) {
            auto i = keyword_ucd_mapping.find(name);
            if (i != keyword_ucd_mapping.end()) {
                prop.add_attribute(tablator::ATTR_UCD, i->second);
            }
        }
    }

    // Add the final prop, if appropriate.
    if (!prev_prop_label.empty() && !prop.empty()) {
        combined_labeled_properties.emplace_back(std::make_pair(prev_prop_label, prop));
    }
    return combined_labeled_properties;
}

}  // namespace


void tablator::Table::read_fits(const boost::filesystem::path &path) {
    CCfits::FITS fits(path.string(), CCfits::Read, false);
    if (fits.extension().empty())
        throw std::runtime_error("Could not find any extensions in this file: " +
                                 path.string());
    CCfits::ExtHDU &table_extension = *(fits.extension().begin()->second);

    //*********************************************************
    // Retrieve FITS keywords in the form of labeled_properties.
    //*********************************************************

    const std::vector<std::pair<std::string, Property>> combined_labeled_properties =
            read_keywords_as_labeled_properties(table_extension);

    //*********************************************************
    // Distribute the labeled_properties between assorted class
    // members at assorted levels.
    //*********************************************************

    Labeled_Properties resource_element_labeled_properties;
    std::vector<Property> resource_element_trailing_infos;
    ATTRIBUTES resource_element_attributes;
    std::vector<Property> table_element_trailing_infos;
    ATTRIBUTES table_element_attributes;
    distribute_metadata(resource_element_labeled_properties,
                        resource_element_trailing_infos, resource_element_attributes,
                        table_element_trailing_infos, table_element_attributes,
                        combined_labeled_properties);

    //*********************************************************
    // Retrieve column metadata.
    //*********************************************************

    std::vector<Column> columns;
    std::vector<size_t> offsets = {0};

    // CCfits is 1 based, not 0 based.
    CCfits::BinTable *ccfits_table(dynamic_cast<CCfits::BinTable *>(&table_extension));
    const bool has_null_bitfield_flags(ccfits_table->column().size() > 0 &&
                                       ccfits_table->column(1).name() ==
                                               null_bitfield_flags_name &&
                                       ccfits_table->column(1).type() == CCfits::Tbyte);
    if (!has_null_bitfield_flags) {
        tablator::append_column(columns, offsets, null_bitfield_flags_name,
                                Data_Type::UINT8_LE,
                                bits_to_bytes(ccfits_table->column().size()),
                                Field_Properties(null_bitfield_flags_description, {}));
    }

    for (size_t i = 0; i < ccfits_table->column().size(); ++i) {
        CCfits::Column &c = ccfits_table->column(i + 1);
        size_t array_size = 1;
        if (std::isdigit(c.format().at(0))) array_size = std::stoll(c.format());
        switch (c.type()) {
            case CCfits::Tlogical:
                tablator::append_column(columns, offsets, c.name(), Data_Type::INT8_LE,
                                        array_size);
                break;
            case CCfits::Tbyte:
                tablator::append_column(columns, offsets, c.name(), Data_Type::UINT8_LE,
                                        array_size);
                break;
            case CCfits::Tshort:
                tablator::append_column(columns, offsets, c.name(), Data_Type::INT16_LE,
                                        array_size);
                break;
            case CCfits::Tushort:
                tablator::append_column(columns, offsets, c.name(),
                                        Data_Type::UINT16_LE, array_size);
                break;
            case CCfits::Tint:
                tablator::append_column(columns, offsets, c.name(), Data_Type::INT32_LE,
                                        array_size);
                break;
            case CCfits::Tuint:
                tablator::append_column(columns, offsets, c.name(),
                                        Data_Type::UINT32_LE, array_size);
                break;
            case CCfits::Tlong:
                // The Tlong type code is used for 32-bit integer columns when reading.
                tablator::append_column(columns, offsets, c.name(), Data_Type::INT32_LE,
                                        array_size);
                break;
            case CCfits::Tulong:
                // The Tulong type code is used for 32-bit unsigned integer columns when
                // reading.
                tablator::append_column(columns, offsets, c.name(),
                                        Data_Type::UINT32_LE, array_size);
                break;
            case CCfits::Tlonglong:
                tablator::append_column(columns, offsets, c.name(), Data_Type::INT64_LE,
                                        array_size);
                break;
            case CCfits::Tfloat: {
                Field_Properties nan_nulls;
                nan_nulls.get_values().null =
                        std::to_string(std::numeric_limits<float>::quiet_NaN());
                tablator::append_column(columns, offsets, c.name(),
                                        Data_Type::FLOAT32_LE, array_size, nan_nulls);
            } break;
            case CCfits::Tdouble: {
                Field_Properties nan_nulls;
                nan_nulls.get_values().null =
                        std::to_string(std::numeric_limits<double>::quiet_NaN());
                tablator::append_column(columns, offsets, c.name(),
                                        Data_Type::FLOAT64_LE, array_size, nan_nulls);
            } break;
            case CCfits::Tstring:
                tablator::append_column(columns, offsets, c.name(), Data_Type::CHAR,
                                        c.width());
                break;
            default:
                throw std::runtime_error(
                        "Unsupported data type in the fits file for "
                        "column '" +
                        c.name() + "'");
        }
    }

    //*********************************************************
    // Retrieve data.
    //*********************************************************

    // ccfits_table->rows () returns an int, so there may be issues with more
    // than 2^32 rows.

    std::vector<uint8_t> data;
    size_t row_size = tablator::row_size(offsets);
    data.resize(ccfits_table->rows() * row_size);
    //    fitsfile *fits_pointer = fits.fitsPointer();

    // CCfits dies in read_column() if there is no data in the table. :(
    if (!data.empty()) {
        fitsfile *fits_pointer = fits.fitsPointer();
        const size_t column_data_offset(has_null_bitfield_flags ? 0 : 1);
        for (size_t i = 0; i < ccfits_table->column().size(); ++i) {
            const size_t offset(offsets[i + column_data_offset]);
            /// CCfits is 1 based, not 0 based.
            CCfits::Column &c = ccfits_table->column(i + 1);
            const bool is_array(std::isdigit(c.format().at(0)) &&
                                (std::stoll(c.format()) != 1));
            switch (c.type()) {
                case CCfits::Tlogical: {
                    if (!is_array) {
                        std::vector<int> v;
                        c.read(v, 1, ccfits_table->rows());
                        size_t element_offset = offset;
                        for (auto &element : v) {
                            data[element_offset] = element;
                            element_offset += row_size;
                        }
                    } else {
                        // FIXME: Use the C api because Column::readArrays is
                        // horrendously slow.
                        std::vector<std::valarray<int>> v;
                        c.readArrays(v, 1, ccfits_table->rows());
                        size_t start_offset_for_row = offset;
                        for (auto &array : v) {
                            auto element_offset = start_offset_for_row;
                            for (auto &element : array) {
                                data[element_offset] = element;
                                ++element_offset;
                            }
                            start_offset_for_row += row_size;
                        }
                    }
                } break;
                case CCfits::Tbyte:
                    read_column<uint8_t>(fits_pointer, data.data() + offset, c,
                                         is_array, ccfits_table->rows(), row_size);
                    break;
                case CCfits::Tshort:
                    read_column<int16_t>(fits_pointer, data.data() + offset, c,
                                         is_array, ccfits_table->rows(), row_size);
                    break;
                case CCfits::Tushort:
                    read_column<uint16_t>(fits_pointer, data.data() + offset, c,
                                          is_array, ccfits_table->rows(), row_size);
                    break;
                case CCfits::Tuint:
                case CCfits::Tulong:
                    read_column<uint32_t>(fits_pointer, data.data() + offset, c,
                                          is_array, ccfits_table->rows(), row_size);
                    break;
                case CCfits::Tint:
                case CCfits::Tlong:
                    read_column<int32_t>(fits_pointer, data.data() + offset, c,
                                         is_array, ccfits_table->rows(), row_size);
                    break;
                case CCfits::Tlonglong:
                    read_column<int64_t>(fits_pointer, data.data() + offset, c,
                                         is_array, ccfits_table->rows(), row_size);
                    break;
                case CCfits::Tfloat:
                    read_column<float>(fits_pointer, data.data() + offset, c, is_array,
                                       ccfits_table->rows(), row_size);
                    break;
                case CCfits::Tdouble:
                    read_column<double>(fits_pointer, data.data() + offset, c, is_array,
                                        ccfits_table->rows(), row_size);
                    break;
                case CCfits::Tstring: {
                    std::vector<std::string> v;
                    c.read(v, 1, ccfits_table->rows());
                    size_t element_offset = offset;
                    for (auto &element : v) {
                        for (size_t j = 0; j < element.size(); ++j)
                            data[element_offset + j] = element[j];
                        for (int j = element.size(); j < c.width(); ++j)
                            data[element_offset + j] = '\0';
                        element_offset += row_size;
                    }
                } break;
                default:
                    throw std::runtime_error(
                            "Unsupported data type in the fits file for "
                            "column " +
                            c.name());
            }
            // FIXME: This should get the comment, but the comment()
            // function is protected???
            if (!c.unit().empty()) {
                columns[i + column_data_offset].get_field_properties().set_attributes(
                        {{"unit", c.unit()}});
            }
        }
    }

    //*********************************************************
    // Assemble resource element.
    //*********************************************************

    const auto table_element =
            Table_Element::Builder(columns, offsets, data)
                    .add_trailing_info_list(table_element_trailing_infos)
                    .add_attributes(table_element_attributes)
                    .build();
    add_resource_element(
            Resource_Element::Builder(table_element)
                    .add_labeled_properties(resource_element_labeled_properties)
                    .add_trailing_info_list(resource_element_trailing_infos)
                    .add_attributes(resource_element_attributes)
                    .build());
}
